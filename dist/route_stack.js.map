{"version":3,"file":"route_stack.js","sourceRoot":"","sources":["../lib/route_stack.ts"],"names":[],"mappings":"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","sourcesContent":["import * as parseUrl from 'parseurl'\nimport {MicroResponse, MicroResponseBuilder} from './response'\nimport {MicroRequest, MicroRequestBuilder} from './request'\nimport {IncomingMessage, ServerResponse} from 'http'\nimport {HTTPStatusCodes} from './status_codes'\n\nexport interface StackItem {\n    path: string\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'\n    handler: (req: MicroRequest, res: MicroResponse) => void\n}\n\nexport interface RouteStackGroup {\n    [method: string]: StackItem[]\n}\n\nexport class RouteStackCompiler {\n\n    /**\n     * All path stack collected from the MicroMethod decorator will\n     * end up here to be path-matched for each incoming request.\n     * Filtering by method first has significant performance impact\n     * @type {RouteStackGroup[]}\n     * @private\n     */\n    private _routeStack: RouteStackGroup = {\n        GET: [],\n        POST: [],\n        PUT: [],\n        DELETE: [],\n        PATCH: []\n    }\n\n    addStack(...stackItems: StackItem[]): void {\n\n        // Ensure stackItems is an array\n        stackItems = [].concat(stackItems)\n\n        // Adds all provided path stack to the _routeStack property\n        stackItems.forEach(_stack => {\n\n            const targetStack = this._routeStack[_stack.method]\n\n            targetStack.push(_stack)\n        })\n    }\n\n    /**\n     * Make as efficient as possible, this is the only function\n     * that is run to map incoming requests.\n     * Treat this as the most performance sensitive function of all\n     */\n    matchRequest(req: IncomingMessage, res: ServerResponse) {\n\n        /**\n         * TODO(global): Do not use global namespace\n         * @date - 5/26/17\n         * @time - 12:14 PM\n         */\n        const liteMode: boolean = typeof global['LITE_MODE'] !== 'undefined' && global['LITE_MODE']\n\n        const incomingRequestRoute = parseUrl(req).pathname\n\n        if (incomingRequestRoute.includes('favicon')) {\n            res.writeHead(204, {'Content-Type': 'plain/text'})\n            res.end()\n            return\n        }\n\n        const matchingRoutesStack = this._routeStack[req.method]\n\n        // If LITE_MODE is enabled, we only need to match the method as there\n        // can only be a single instance for each method\n        if (liteMode) {\n            //\n            const mResponse = MicroResponseBuilder.create(res)\n            const mRequest = MicroRequestBuilder.create(req)\n            matchingRoutesStack[0].handler(mRequest, mResponse)\n            return\n        }\n\n        // Found a matching routerName stack\n        let routeMatch\n\n        // Found parameters inside path path\n        let params = {}\n\n        // Incoming request URL split by slashes. Used for path matching later\n        // e.g /users/userName => ['users', 'username']\n        const pathChunks = incomingRequestRoute.replace(/^\\/+|\\/+^/, '').split('/')\n\n        for (let i = 0; i < matchingRoutesStack.length; i++) {\n\n            // The currently iterated routerName stack\n            const curr = matchingRoutesStack[i]\n\n            // Break loop if exact root match found\n            if (curr.path === incomingRequestRoute) {\n                routeMatch = curr\n                break\n            }\n\n            // Checks if the currently iterated routeStack has a parameter identifier.\n            // If it does not, immediately continue loop. Regex checking function below\n            // this point is expensive, we want to prevent from doing it if not necessary.\n            // e.g @MicroMethod.Post('/users/:userId') or ('/foo*')\n            if (!/\\/?:(.*)|\\*/g.test(curr.path)) continue\n\n            const matchChunks = curr.path.replace(/^\\/+|\\/+^/, '').split('/')\n\n            // Continue loop early if request URL and currently iterated\n            // router stack does not match in chunks length\n            if (pathChunks.length !== matchChunks.length) continue\n\n            for (let i = 0; i < matchChunks.length; i++) {\n\n                const capture = matchChunks[i]\n\n                if (/^:/.test(capture)) {\n                    params[capture.replace(/^:/i, '')] = pathChunks[i]\n                }\n            }\n\n            /*\n             // REMOVE path-to-regex\n             // MicroRequest should bind params data to the request\n             // e.g req.params.userId = `value of :userId`\n             // TODO(perf): offload path matching to C module\n             const reg = pathToRegexp(curr.path)\n\n             // Tries to look up a match to the incoming request's URL\n             const regExec = reg.exec(incomingRequestRoute)\n\n             // If no match found, return immediately\n             if (!regExec) continue\n\n             for (let i = 0; i < reg.keys.length; i++) {\n             const matchValue = regExec[i + 1]\n             const matchKey = reg.keys[i].name\n             // Assign the matching parameters to the params object\n             // to be passed on to the MicroResponse\n             params[matchKey] = matchValue\n             }\n             */\n\n            // If any matching params were found\n            // mark the currently iterated routerStack as a match\n            // and break out of the loop\n            if (Object.keys(params).length) {\n                routeMatch = curr\n                break\n            }\n        }\n\n        const mResponse = MicroResponseBuilder.create(res)\n\n        if (!routeMatch) {\n            // No matching path handler found return 404\n            mResponse.status(HTTPStatusCodes.NOT_FOUND).send('Not Found')\n            return\n        }\n\n        const mRequest = MicroRequestBuilder.create(req)\n\n        // Attach params to current request context\n        if (params) mRequest.params = params\n\n        routeMatch.handler(mRequest, mResponse)\n    }\n}\n\nexport const RouteStack = new RouteStackCompiler()\n"]}