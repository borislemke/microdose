{"version":3,"file":"route_stack.js","sourceRoot":"","sources":["../lib/route_stack.ts"],"names":[],"mappings":";;AAAA,mCAAoC;AACpC,uCAA8D;AAC9D,qCAA2D;AAE3D,+CAA8C;AAY9C,IAAM,WAAW,GAAG,UAAC,GAAmB;IACpC,GAAG,CAAC,SAAS,CAAC,8BAAe,CAAC,SAAS,EAAE,EAAC,cAAc,EAAE,YAAY,EAAC,CAAC,CAAA;IACxE,GAAG,CAAC,GAAG,CAAC,WAAW,CAAC,CAAA;AACxB,CAAC,CAAA;AAED;IAAA;QAEI;;;;;;WAMG;QACK,gBAAW,GAAoB;YACnC,GAAG,EAAE,EAAE;YACP,IAAI,EAAE,EAAE;YACR,GAAG,EAAE,EAAE;YACP,MAAM,EAAE,EAAE;YACV,KAAK,EAAE,EAAE;SACZ,CAAA;IA6IL,CAAC;IA3IG,qCAAQ,GAAR;QAAA,iBAYC;QAZQ,oBAA0B;aAA1B,UAA0B,EAA1B,qBAA0B,EAA1B,IAA0B;YAA1B,+BAA0B;;QAE/B,gCAAgC;QAChC,UAAU,GAAG,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,CAAA;QAElC,2DAA2D;QAC3D,UAAU,CAAC,OAAO,CAAC,UAAA,MAAM;YAErB,IAAM,WAAW,GAAG,KAAI,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;YAEnD,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QAC5B,CAAC,CAAC,CAAA;IACN,CAAC;IAED;;;;OAIG;IACH,yCAAY,GAAZ,UAAa,GAAoB,EAAE,GAAmB;QAElD;;;;WAIG;QACH,IAAM,SAAS,GAAY,OAAO,MAAM,CAAC,YAAY,CAAC,KAAK,WAAW,IAAI,MAAM,CAAC,YAAY,CAAC,CAAA;QAE9F,IAAM,mBAAmB,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;QAExD,wDAAwD;QACxD,EAAE,CAAC,CAAC,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC,CAAC;YAC9B,WAAW,CAAC,GAAG,CAAC,CAAA;YAChB,MAAM,CAAA;QACV,CAAC;QAED,0EAA0E;QAC1E,uEAAuE;QACvE,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YACZ,IAAM,WAAS,GAAG,+BAAoB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;YAClD,IAAM,UAAQ,GAAG,6BAAmB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;YAChD,sDAAsD;YACtD,mBAAmB,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,UAAQ,EAAE,WAAS,CAAC,CAAA;YACnD,yDAAyD;YACzD,EAAE,CAAC,CAAC,mBAAmB,CAAC,MAAM,GAAG,CAAC,IAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY,CAAC,CAAC,CAAC;gBAC1E,OAAO,CAAC,GAAG,CAAC,EAAE,CAAC,CAAA;gBACf,OAAO,CAAC,GAAG,CAAC,mBAAmB,EAAE,mGAClB,GAAG,CAAC,MAAM,iBAAc,CAAC,CAAA;YAC5C,CAAC;YACD,MAAM,CAAA;QACV,CAAC;QAED,iCAAiC;QACjC,IAAM,mBAAmB,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAA;QAElD;;;;WAIG;QACH,EAAE,CAAC,CAAC,mBAAmB,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YAC1C,GAAG,CAAC,SAAS,CAAC,GAAG,EAAE,EAAC,cAAc,EAAE,YAAY,EAAC,CAAC,CAAA;YAClD,GAAG,CAAC,GAAG,EAAE,CAAA;YACT,MAAM,CAAA;QACV,CAAC;QAED,wDAAwD;QACxD,IAAI,UAAU,CAAA;QAEd,oCAAoC;QACpC,IAAI,MAAM,GAAG,EAAE,CAAA;QAEf,sEAAsE;QACtE,+CAA+C;QAC/C,IAAM,UAAU,GAAG,mBAAmB,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;QAE1E,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAElD,0CAA0C;YAC1C,IAAM,IAAI,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAA;YAEnC,uCAAuC;YACvC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,mBAAmB,CAAC,CAAC,CAAC;gBACpC,UAAU,GAAG,IAAI,CAAA;gBACjB,KAAK,CAAA;YACT,CAAC;YAED,0EAA0E;YAC1E,2EAA2E;YAC3E,8EAA8E;YAC9E,uDAAuD;YACvD,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAAC,QAAQ,CAAA;YAE7C,IAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;YAEjE,4DAA4D;YAC5D,+CAA+C;YAC/C,EAAE,CAAC,CAAC,UAAU,CAAC,MAAM,KAAK,WAAW,CAAC,MAAM,CAAC;gBAAC,QAAQ,CAAA;YAEtD,8BAA8B;YAC9B,GAAG,CAAC,CAAC,IAAI,GAAC,GAAG,CAAC,EAAE,GAAC,GAAG,WAAW,CAAC,MAAM,EAAE,GAAC,EAAE,EAAE,CAAC;gBAE1C,IAAM,OAAO,GAAG,WAAW,CAAC,GAAC,CAAC,CAAA;gBAE9B,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;oBACrB,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,GAAG,UAAU,CAAC,GAAC,CAAC,CAAA;gBACtD,CAAC;YACL,CAAC;YAED,oCAAoC;YACpC,qDAAqD;YACrD,4BAA4B;YAC5B,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC7B,UAAU,GAAG,IAAI,CAAA;gBACjB,KAAK,CAAA;YACT,CAAC;QACL,CAAC;QAED;;;;WAIG;QACH,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YACd,4CAA4C;YAC5C,WAAW,CAAC,GAAG,CAAC,CAAA;YAChB,MAAM,CAAA;QACV,CAAC;QAED,iFAAiF;QACjF,IAAM,SAAS,GAAG,+BAAoB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QAClD,IAAM,QAAQ,GAAG,6BAAmB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QAEhD,2CAA2C;QAC3C,EAAE,CAAC,CAAC,MAAM,CAAC;YAAC,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAA;QAEpC,iCAAiC;QACjC,UAAU,CAAC,OAAO,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAA;IAC3C,CAAC;IACL,yBAAC;AAAD,CAAC,AA5JD,IA4JC;AA5JY,gDAAkB;AA8JlB,QAAA,UAAU,GAAG,IAAI,kBAAkB,EAAE,CAAA","sourcesContent":["import * as parseUrl from 'parseurl'\nimport {MicroResponse, MicroResponseBuilder} from './response'\nimport {MicroRequest, MicroRequestBuilder} from './request'\nimport {IncomingMessage, ServerResponse} from 'http'\nimport {HTTPStatusCodes} from './status_codes'\n\nexport interface StackItem {\n    path: string\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'\n    handler: (req: MicroRequest, res: MicroResponse) => void\n}\n\nexport interface RouteStackGroup {\n    [method: string]: StackItem[]\n}\n\nconst earlyReturn = (res: ServerResponse) => {\n    res.writeHead(HTTPStatusCodes.NOT_FOUND, {'Content-Type': 'plain/text'})\n    res.end('Not Found')\n}\n\nexport class RouteStackCompiler {\n\n    /**\n     * All path stack collected from the MicroMethod decorator will\n     * end up here to be path-matched for each incoming request.\n     * Filtering by method first has significant performance impact\n     * @type {RouteStackGroup[]}\n     * @private\n     */\n    private _routeStack: RouteStackGroup = {\n        GET: [],\n        POST: [],\n        PUT: [],\n        DELETE: [],\n        PATCH: []\n    }\n\n    addStack(...stackItems: StackItem[]): void {\n\n        // Ensure stackItems is an array\n        stackItems = [].concat(stackItems)\n\n        // Adds all provided path stack to the _routeStack property\n        stackItems.forEach(_stack => {\n\n            const targetStack = this._routeStack[_stack.method]\n\n            targetStack.push(_stack)\n        })\n    }\n\n    /**\n     * Make as efficient as possible, this is the only function\n     * that is run to map incoming requests.\n     * Treat this as the most performance sensitive function of all\n     */\n    matchRequest(req: IncomingMessage, res: ServerResponse) {\n\n        /**\n         * TODO(global): Do not use global namespace\n         * @date - 5/26/17\n         * @time - 12:14 PM\n         */\n        const turboMode: boolean = typeof global['TURBO_MODE'] !== 'undefined' && global['TURBO_MODE']\n\n        const matchingRoutesStack = this._routeStack[req.method]\n\n        // Early return if routerStack by method has no handlers\n        if (!matchingRoutesStack.length) {\n            earlyReturn(res)\n            return\n        }\n\n        // If TURBO_MODE is enabled, we only need to match the method as there can\n        // only be a single instance for each method. Path matching is disabled\n        if (turboMode) {\n            const mResponse = MicroResponseBuilder.create(res)\n            const mRequest = MicroRequestBuilder.create(req)\n            // Retrieve first handler of the matching router stack\n            matchingRoutesStack[0].handler(mRequest, mResponse)\n            // There can only be 1 handler per method if on turboMode\n            if (matchingRoutesStack.length > 1 && process.env.NODE_ENV !== 'production') {\n                console.log('')\n                console.log('\\x1b[33m%s\\x1b[0m', `WARNING: 'Turbo Mode' is enable but microdose detected multiple\n                handlers for ${req.method} requests.\\n`)\n            }\n            return\n        }\n\n        // The URL of the current request\n        const incomingRequestPath = parseUrl(req).pathname\n\n        /**\n         * TODO(production): Remove, browser testing only\n         * @date - 5/27/17\n         * @time - 2:56 AM\n         */\n        if (incomingRequestPath.includes('favicon')) {\n            res.writeHead(204, {'Content-Type': 'plain/text'})\n            res.end()\n            return\n        }\n\n        // Matching routerStack for the current incoming request\n        let routeMatch\n\n        // Found parameters inside path path\n        let params = {}\n\n        // Incoming request URL split by slashes. Used for path matching later\n        // e.g /users/userName => ['users', 'username']\n        const pathChunks = incomingRequestPath.replace(/^\\/+|\\/+^/, '').split('/')\n\n        for (let i = 0; i < matchingRoutesStack.length; i++) {\n\n            // The currently iterated routerName stack\n            const curr = matchingRoutesStack[i]\n\n            // Break loop if exact root match found\n            if (curr.path === incomingRequestPath) {\n                routeMatch = curr\n                break\n            }\n\n            // Checks if the currently iterated routeStack has a parameter identifier.\n            // If it does not, immediately continue loop. Regex checking function below\n            // this point is expensive, we want to prevent from doing it if not necessary.\n            // e.g @MicroMethod.Post('/users/:userId') or ('/foo*')\n            if (!/\\/?:(.*)|\\*/g.test(curr.path)) continue\n\n            const matchChunks = curr.path.replace(/^\\/+|\\/+^/, '').split('/')\n\n            // Continue loop early if request URL and currently iterated\n            // router stack does not match in chunks length\n            if (pathChunks.length !== matchChunks.length) continue\n\n            // Iterate over route patterns\n            for (let i = 0; i < matchChunks.length; i++) {\n\n                const capture = matchChunks[i]\n\n                if (/^:/.test(capture)) {\n                    params[capture.replace(/^:/i, '')] = pathChunks[i]\n                }\n            }\n\n            // If any matching params were found\n            // mark the currently iterated routerStack as a match\n            // and break out of the loop\n            if (Object.keys(params).length) {\n                routeMatch = curr\n                break\n            }\n        }\n\n        /**\n         * TODO(production): Allow custom override of not found function\n         * @date - 5/27/17\n         * @time - 2:54 AM\n         */\n        if (!routeMatch) {\n            // No matching path handler found return 404\n            earlyReturn(res)\n            return\n        }\n\n        // Create the request and response object only after a route match has been found\n        const mResponse = MicroResponseBuilder.create(res)\n        const mRequest = MicroRequestBuilder.create(req)\n\n        // Attach params to current request context\n        if (params) mRequest.params = params\n\n        // Execute matching route handler\n        routeMatch.handler(mRequest, mResponse)\n    }\n}\n\nexport const RouteStack = new RouteStackCompiler()\n"]}