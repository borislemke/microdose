{"version":3,"file":"route_stack.js","sourceRoot":"","sources":["../lib/route_stack.ts"],"names":[],"mappings":";;AAAA,mCAAoC;AACpC,uCAA8D;AAC9D,qCAA2D;AAE3D,+CAA8C;AAC9C,IAAM,YAAY,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAA;AAe9C;IAAA;QAGI;;;;;WAKG;QACK,gBAAW,GAAoB;YACnC,GAAG,EAAE,EAAE;YACP,IAAI,EAAE,EAAE;YACR,GAAG,EAAE,EAAE;YACP,MAAM,EAAE,EAAE;YACV,KAAK,EAAE,EAAE;SACZ,CAAA;IAyFL,CAAC;IAtFG,qCAAQ,GAAR;QAAA,iBAYC;QAZQ,oBAA0B;aAA1B,UAA0B,EAA1B,qBAA0B,EAA1B,IAA0B;YAA1B,+BAA0B;;QAE/B,gCAAgC;QAChC,UAAU,GAAG,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,CAAA;QAElC,2DAA2D;QAC3D,UAAU,CAAC,OAAO,CAAC,UAAA,MAAM;YAErB,IAAM,WAAW,GAAG,KAAI,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;YAEnD,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QAC5B,CAAC,CAAC,CAAA;IACN,CAAC;IAGD;;;;OAIG;IACH,yCAAY,GAAZ,UAAa,GAAoB,EAAE,GAAmB;QAElD,IAAM,oBAAoB,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAA;QAEnD,IAAM,mBAAmB,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;QAExD,oCAAoC;QACpC,IAAI,UAAU,CAAA;QAEd,oCAAoC;QACpC,IAAI,MAAM,GAAG,EAAE,CAAA;QAEf,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YAElD,0CAA0C;YAC1C,IAAM,IAAI,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAA;YAEnC,uCAAuC;YACvC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,KAAK,oBAAoB,CAAC,CAAC,CAAC;gBACrC,UAAU,GAAG,IAAI,CAAA;gBACjB,KAAK,CAAA;YACT,CAAC;YAED,0EAA0E;YAC1E,2EAA2E;YAC3E,8EAA8E;YAC9E,uDAAuD;YACvD,EAAE,CAAC,CAAC,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBAAC,QAAQ,CAAA;YAE7C,sDAAsD;YACtD,6CAA6C;YAC7C,oDAAoD;YACpD,IAAM,GAAG,GAAG,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;YAEnC,IAAM,OAAO,GAAG,GAAG,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAA;YAE9C,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC;gBAAC,QAAQ,CAAA;YAEtB,GAAG,CAAC,CAAC,IAAI,GAAC,GAAG,CAAC,EAAE,GAAC,GAAG,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,GAAC,EAAE,EAAE,CAAC;gBACvC,IAAM,UAAU,GAAG,OAAO,CAAC,GAAC,GAAG,CAAC,CAAC,CAAA;gBACjC,IAAM,QAAQ,GAAG,GAAG,CAAC,IAAI,CAAC,GAAC,CAAC,CAAC,IAAI,CAAA;gBACjC,MAAM,CAAC,QAAQ,CAAC,GAAG,UAAU,CAAA;YACjC,CAAC;YAED,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBAC7B,UAAU,GAAG,IAAI,CAAA;gBACjB,KAAK,CAAA;YACT,CAAC;QACL,CAAC;QAED,IAAM,SAAS,GAAG,+BAAoB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QAElD,EAAE,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YACd,iCAAiC;YACjC,aAAa;YACb,SAAS,CAAC,MAAM,CAAC,8BAAe,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;YAC7D,MAAM,CAAA;QACV,CAAC;QAED,IAAM,QAAQ,GAAG,6BAAmB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QAEhD,2CAA2C;QAC3C,EAAE,CAAC,CAAC,MAAM,CAAC;YAAC,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAA;QAEpC,UAAU,CAAC,OAAO,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAA;IAC3C,CAAC;IACL,yBAAC;AAAD,CAAC,AAxGD,IAwGC;AAxGY,gDAAkB;AA0GlB,QAAA,UAAU,GAAG,IAAI,kBAAkB,EAAE,CAAA","sourcesContent":["import * as parseUrl from 'parseurl'\nimport {MicroResponse, MicroResponseBuilder} from './response'\nimport {MicroRequest, MicroRequestBuilder} from './request'\nimport {IncomingMessage, ServerResponse} from 'http'\nimport {HTTPStatusCodes} from './status_codes'\nconst pathToRegexp = require('path-to-regexp')\n\n\nexport interface StackItem {\n    path: string\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'\n    handler: (req: MicroRequest, res: MicroResponse) => void\n}\n\n\nexport interface RouteStackGroup {\n    [method: string]: StackItem[]\n}\n\n\nexport class RouteStackCompiler {\n\n\n    /**\n     * All path stack collected from the MicroMethod decorator will\n     * end up here to be path-matched for each incoming request\n     * @type {RouteStackGroup[]}\n     * @private\n     */\n    private _routeStack: RouteStackGroup = {\n        GET: [],\n        POST: [],\n        PUT: [],\n        DELETE: [],\n        PATCH: []\n    }\n\n\n    addStack(...stackItems: StackItem[]): void {\n\n        // Ensure stackItems is an array\n        stackItems = [].concat(stackItems)\n\n        // Adds all provided path stack to the _routeStack property\n        stackItems.forEach(_stack => {\n\n            const targetStack = this._routeStack[_stack.method]\n\n            targetStack.push(_stack)\n        })\n    }\n\n\n    /**\n     * Make as efficient as possible, this is the only function\n     * that is run to map incoming requests.\n     * Treat this function as the most performance sensitive ever. EVER.\n     */\n    matchRequest(req: IncomingMessage, res: ServerResponse) {\n\n        const incomingRequestRoute = parseUrl(req).pathname\n\n        const matchingRoutesStack = this._routeStack[req.method]\n\n        // Found a matching routerName stack\n        let routeMatch\n\n        // Found parameters inside path path\n        let params = {}\n\n        for (let i = 0; i < matchingRoutesStack.length; i++) {\n\n            // The currently iterated routerName stack\n            const curr = matchingRoutesStack[i]\n\n            // Break loop if exact root match found\n            if (curr.path === incomingRequestRoute) {\n                routeMatch = curr\n                break\n            }\n\n            // Checks if the currently iterated routeStack has a parameter identifier.\n            // If it does not, immediately continue loop. Regex checking function below\n            // this point is expensive, we want to prevent from doing it if not necessary.\n            // e.g @MicroMethod.Post('/users/:userId') or ('/foo*')\n            if (!/\\/?:(.*)|\\*/g.test(curr.path)) continue\n\n            // MicroRequest should bind params data to the request\n            // e.g req.params.userId = `value of :userId`\n            /** TODO(perf): offload path matching to C module */\n            const reg = pathToRegexp(curr.path)\n\n            const regExec = reg.exec(incomingRequestRoute)\n\n            if (!regExec) continue\n\n            for (let i = 0; i < reg.keys.length; i++) {\n                const matchValue = regExec[i + 1]\n                const matchKey = reg.keys[i].name\n                params[matchKey] = matchValue\n            }\n\n            if (Object.keys(params).length) {\n                routeMatch = curr\n                break\n            }\n        }\n\n        const mResponse = MicroResponseBuilder.create(res)\n\n        if (!routeMatch) {\n            // No matching path handler found\n            // Return 404\n            mResponse.status(HTTPStatusCodes.NOT_FOUND).send('Not Found')\n            return\n        }\n\n        const mRequest = MicroRequestBuilder.create(req)\n\n        // Attach params to current request context\n        if (params) mRequest.params = params\n\n        routeMatch.handler(mRequest, mResponse)\n    }\n}\n\nexport const RouteStack = new RouteStackCompiler()\n"]}