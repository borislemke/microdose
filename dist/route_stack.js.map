{"version":3,"file":"route_stack.js","sourceRoot":"","sources":["../src/route_stack.ts"],"names":[],"mappings":";;AAAA,mCAAoC;AACpC,uCAAwD;AACxD,qCAAqD;AAErD,+CAAgD;AAChD,6BAA4B;AAY5B,IAAM,WAAW,GAAG,UAAC,GAAmB;IACtC,GAAG,CAAC,SAAS,CAAC,8BAAe,CAAC,SAAS,EAAE,2BAAgB,CAAC,sBAAsB,CAAC,CAAA;IACjF,GAAG,CAAC,GAAG,CAAC,WAAW,CAAC,CAAA;AACtB,CAAC,CAAA;AAED;IAAA;QAEE;;;;;WAKG;QACH,eAAU,GAAoB;YAC5B,GAAG,EAAE,EAAE;YACP,IAAI,EAAE,EAAE;YACR,GAAG,EAAE,EAAE;YACP,MAAM,EAAE,EAAE;YACV,KAAK,EAAE,EAAE;SACV,CAAA;IAwHH,CAAC;IAtHC,8BAAQ,GAAR;QAAA,iBAYC;QAZS,oBAA0B;aAA1B,UAA0B,EAA1B,qBAA0B,EAA1B,IAA0B;YAA1B,+BAA0B;;QAElC,gCAAgC;QAChC,UAAU,GAAG,EAAE,CAAC,MAAM,CAAC,UAAU,CAAC,CAAA;QAElC,2DAA2D;QAC3D,UAAU,CAAC,OAAO,CAAC,UAAA,MAAM;YAEvB,IAAM,WAAW,GAAG,KAAI,CAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,CAAA;YAElD,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAA;QAC1B,CAAC,CAAC,CAAA;IACJ,CAAC;IAED;;;;OAIG;IACH,kCAAY,GAAZ,UAAc,GAAoB,EAAE,GAAmB;QACrD,IAAM,mBAAmB,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,CAAA;QAErE,wDAAwD;QACxD,IAAI,CAAC,mBAAmB,CAAC,MAAM,EAAE;YAC/B,WAAW,CAAC,GAAG,CAAC,CAAA;YAChB,OAAM;SACP;QAED,0EAA0E;QAC1E,8EAA8E;QAC9E,IAAI,UAAI,CAAC,UAAU,EAAE;YACnB,IAAM,SAAS,GAAG,2BAAgB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;YAE9C,IAAM,QAAQ,GAAG,yBAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;YAE5C,sDAAsD;YACtD,OAAO,mBAAmB,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAA;SAC3D;QAED,iCAAiC;QACjC,IAAM,mBAAmB,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAA;QAElD,wDAAwD;QACxD,IAAI,UAAU,CAAA;QAEd,oCAAoC;QACpC,IAAI,MAAM,GAAG,EAAE,CAAA;QAEf,sEAAsE;QACtE,+CAA+C;QAC/C,IAAM,UAAU,GAAG,mBAAmB,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;QAE1E,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,mBAAmB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAEnD,0CAA0C;YAC1C,IAAM,IAAI,GAAG,mBAAmB,CAAC,CAAC,CAAC,CAAA;YAEnC,uCAAuC;YACvC,IAAI,IAAI,CAAC,IAAI,KAAK,mBAAmB,EAAE;gBACrC,UAAU,GAAG,IAAI,CAAA;gBACjB,MAAK;aACN;YAED,0EAA0E;YAC1E,2EAA2E;YAC3E,8EAA8E;YAC9E,uDAAuD;YACvD,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;gBAAE,SAAQ;YAE7C,IAAM,WAAW,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,CAAA;YAEjE,4DAA4D;YAC5D,+CAA+C;YAC/C,IAAI,UAAU,CAAC,MAAM,KAAK,WAAW,CAAC,MAAM;gBAAE,SAAQ;YAEtD,8BAA8B;YAC9B,KAAK,IAAI,GAAC,GAAG,CAAC,EAAE,GAAC,GAAG,WAAW,CAAC,MAAM,EAAE,GAAC,EAAE,EAAE;gBAE3C,IAAM,OAAO,GAAG,WAAW,CAAC,GAAC,CAAC,CAAA;gBAE9B,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;oBACtB,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,GAAG,UAAU,CAAC,GAAC,CAAC,CAAA;iBACnD;aACF;YAED,oCAAoC;YACpC,qDAAqD;YACrD,4BAA4B;YAC5B,IAAI,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE;gBAC9B,UAAU,GAAG,IAAI,CAAA;gBACjB,MAAK;aACN;SACF;QAED;;;;WAIG;QACH,IAAI,CAAC,UAAU,EAAE;YACf,4CAA4C;YAC5C,WAAW,CAAC,GAAG,CAAC,CAAA;YAChB,OAAM;SACP;QAED,iFAAiF;QACjF,IAAM,SAAS,GAAG,2BAAgB,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QAE9C,IAAM,QAAQ,GAAG,yBAAe,CAAC,MAAM,CAAC,GAAG,CAAC,CAAA;QAE5C,2CAA2C;QAC3C,IAAI,MAAM,EAAE;YACV,QAAQ,CAAC,MAAM,GAAG,MAAM,CAAA;SACzB;QAED,iCAAiC;QACjC,UAAU,CAAC,OAAO,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAA;IACzC,CAAC;IACH,kBAAC;AAAD,CAAC,AAtID,IAsIC;AAtIY,kCAAW;AAwIX,QAAA,UAAU,GAAG,IAAI,WAAW,EAAE,CAAA","sourcesContent":["import * as parseUrl from 'parseurl'\nimport { uResponse, uResponseBuilder } from './response'\nimport { uRequest, uRequestBuilder } from './request'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { HTTPStatusCodes } from './status_codes'\nimport { uApp } from './app'\n\nexport interface StackItem {\n  path: string\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'\n  handler: (req: uRequest, res: uResponse) => void\n}\n\nexport interface RouteStackGroup {\n  [method: string]: StackItem[]\n}\n\nconst earlyReturn = (res: ServerResponse) => {\n  res.writeHead(HTTPStatusCodes.NOT_FOUND, uResponseBuilder.defaultResponseHeaders)\n  res.end('Not Found')\n}\n\nexport class RouteStackC {\n\n  /**\n   * All path stack collected from the MicroMethod decorator will\n   * end up here to be path-matched for each incoming request.\n   * Filtering by method first has significant performance impact\n   * @type {RouteStackGroup[]}\n   */\n  routeStack: RouteStackGroup = {\n    GET: [],\n    POST: [],\n    PUT: [],\n    DELETE: [],\n    PATCH: []\n  }\n\n  addStack (...stackItems: StackItem[]): void {\n\n    // Ensure stackItems is an array\n    stackItems = [].concat(stackItems)\n\n    // Adds all provided path stack to the _routeStack property\n    stackItems.forEach(_stack => {\n\n      const targetStack = this.routeStack[_stack.method]\n\n      targetStack.push(_stack)\n    })\n  }\n\n  /**\n   * Make as efficient as possible, this is the only function\n   * that is run to map incoming requests.\n   * Treat this as the most performance sensitive function of all\n   */\n  matchRequest (req: IncomingMessage, res: ServerResponse) {\n    const matchingRoutesStack = this.routeStack[req.method.toUpperCase()]\n\n    // Early return if routerStack by method has no handlers\n    if (!matchingRoutesStack.length) {\n      earlyReturn(res)\n      return\n    }\n\n    // If TURBO_MODE is enabled, we only need to match the method as there can\n    // only be a single handler function of each method. Path matching is disabled\n    if (uApp.TURBO_MODE) {\n      const mResponse = uResponseBuilder.create(res)\n\n      const mRequest = uRequestBuilder.create(req)\n\n      // Retrieve first handler of the matching router stack\n      return matchingRoutesStack[0].handler(mRequest, mResponse)\n    }\n\n    // The URL of the current request\n    const incomingRequestPath = parseUrl(req).pathname\n\n    // Matching routerStack for the current incoming request\n    let routeMatch\n\n    // Found parameters inside path path\n    let params = {}\n\n    // Incoming request URL split by slashes. Used for path matching later\n    // e.g /users/userName => ['users', 'username']\n    const pathChunks = incomingRequestPath.replace(/^\\/+|\\/+^/, '').split('/')\n\n    for (let i = 0; i < matchingRoutesStack.length; i++) {\n\n      // The currently iterated routerName stack\n      const curr = matchingRoutesStack[i]\n\n      // Break loop if exact root match found\n      if (curr.path === incomingRequestPath) {\n        routeMatch = curr\n        break\n      }\n\n      // Checks if the currently iterated routeStack has a parameter identifier.\n      // If it does not, immediately continue loop. Regex checking function below\n      // this point is expensive, we want to prevent from doing it if not necessary.\n      // e.g @MicroMethod.Post('/users/:userId') or ('/foo*')\n      if (!/\\/?:(.*)|\\*/g.test(curr.path)) continue\n\n      const matchChunks = curr.path.replace(/^\\/+|\\/+^/, '').split('/')\n\n      // Continue loop early if request URL and currently iterated\n      // router stack does not match in chunks length\n      if (pathChunks.length !== matchChunks.length) continue\n\n      // Iterate over route patterns\n      for (let i = 0; i < matchChunks.length; i++) {\n\n        const capture = matchChunks[i]\n\n        if (/^:/.test(capture)) {\n          params[capture.replace(/^:/i, '')] = pathChunks[i]\n        }\n      }\n\n      // If any matching params were found\n      // mark the currently iterated routerStack as a match\n      // and break out of the loop\n      if (Object.keys(params).length) {\n        routeMatch = curr\n        break\n      }\n    }\n\n    /**\n     * TODO(production): Allow custom override of not found function\n     * @date - 5/27/17\n     * @time - 2:54 AM\n     */\n    if (!routeMatch) {\n      // No matching path handler found return 404\n      earlyReturn(res)\n      return\n    }\n\n    // Create the request and response object only after a route match has been found\n    const uResponse = uResponseBuilder.create(res)\n\n    const uRequest = uRequestBuilder.create(req)\n\n    // Attach params to current request context\n    if (params) {\n      uRequest.params = params\n    }\n\n    // Execute matching route handler\n    routeMatch.handler(uRequest, uResponse)\n  }\n}\n\nexport const RouteStack = new RouteStackC()\n"]}